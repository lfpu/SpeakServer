#include "server.hpp"
#include <iostream>
#include "control_message.hpp"

VoiceServer::VoiceServer(boost::asio::io_context &io_context, ServerConfig config)
    : io_context_(io_context),
      socket_(io_context, udp::endpoint(udp::v4(), config.port)),
      recv_buffer_(1024),
      running_(false),
      audio_stream_manager_(socket_),
      config_(config),
      pool_(4), // 线程池大小
      strand_(boost::asio::make_strand(io_context))
{
}

void VoiceServer::start()
{
    running_ = true;
    startReceive();
    std::cout << "Voice server started on port " << socket_.local_endpoint().port()
              << " with max connections: " << config_.max_connections << std::endl;


    // 多线程运行 io_context，避免阻塞
    for (int i = 0; i < std::thread::hardware_concurrency(); ++i)
    {
        std::thread([this] { io_context_.run(); }).detach();
    }

    // 清理线程
    std::thread([this] {
        while (running_) {
            std::this_thread::sleep_for(std::chrono::seconds(10));
            cleanupInactiveSessions();
            audio_stream_manager_.unregisterInactiveClients();
        }
    }).detach();

}

void VoiceServer::stop()
{
    running_ = false;
    socket_.close();
    std::cout << "Voice server stopped." << std::endl;
}

void VoiceServer::startReceive()
{
    socket_.async_receive_from(
        boost::asio::buffer(recv_buffer_), remote_endpoint_,
        [this](boost::system::error_code error, std::size_t bytes_recvd)
        {
            if (!error && bytes_recvd > 0)
            {
                std::string client_id = remote_endpoint_.address().to_string() + ":" + std::to_string(remote_endpoint_.port());
                udp::endpoint endpoint = remote_endpoint_; // ✅ 复制
                std::vector<char> data(recv_buffer_.begin(), recv_buffer_.begin() + bytes_recvd);

                boost::asio::post(pool_, [this, client_id, endpoint, data = std::move(data)]() mutable {
                    dispatchMessage(client_id, endpoint, std::move(data));
                });
            }
            else if (error)
            {
                std::cerr << "Receive error: " << error.message() << std::endl;
            }

            if (running_)
                startReceive();
        });
}

// ===================== 消息解析 =====================
MessageType VoiceServer::parseMessageTypes(const std::vector<char> &data)
{
    std::string_view msg(data.data(), data.size());
    if (msg._Starts_with("handshake")) return MessageType::Handshake;
    if (msg._Starts_with("heartbeat")) return MessageType::Heartbeat;
    if (msg == "GetUsers") return MessageType::GetUsers;
    if (msg == "receive") return MessageType::Receive;
    if (data[0] == 0x001) return MessageType::SpeakingStart;
    if (data[0] == 0x002) return MessageType::SpeakingStop;
    return MessageType::Audio;
}

void VoiceServer::dispatchMessage(const std::string &client_id, const udp::endpoint &endpoint, std::vector<char> data)
{
    MessageType type = parseMessageTypes(data);
    std::string_view msg(data.data(), data.size());

    switch (type)
    {
    case MessageType::Handshake:
        handleHandshake(client_id, endpoint, msg);
        break;
    case MessageType::Heartbeat:
        handleHeartbeat(client_id, endpoint, msg);
        break;
    case MessageType::GetUsers:
        handleGetUsers(client_id, endpoint);
        break;
    case MessageType::Receive:
        handleReceive(client_id, endpoint);
        break;
    case MessageType::SpeakingStart:
        setSpeaking(client_id, true);
        break;
    case MessageType::SpeakingStop:
        setSpeaking(client_id, false);
        break;
    case MessageType::Audio:
        handleAudio(client_id, data);
        break;
    default:
        break;
    }
}

// ===================== 独立处理函数 =====================
void VoiceServer::handleHandshake(const std::string &client_id, const udp::endpoint &endpoint, std::string_view msg)
{
    std::lock_guard<std::mutex> lock(session_mutex_);
    int recievePort = std::stoi(std::string(msg.substr(10)));
    auto it = client_sessions_.find(client_id);
    if (it == client_sessions_.end())
    {
        if (client_sessions_.size() >= static_cast<size_t>(config_.max_connections))
        {
            std::cerr << "Max connections reached. Rejecting client: " << client_id << std::endl;
            boost::asio::post(io_context_,[this, endpoint]() mutable {
                ControlMessageSender control_sender(socket_);
                control_sender.sendReject(endpoint, "Server is full. Try again later.");
            });
            return;
        }
        auto session = std::make_shared<ClientSession>(endpoint);
        session->SetRecievePoint(recievePort);
        client_sessions_[client_id] = session;
    }
    else
    {
        it->second->updateLastActive();
        it->second->SetRecievePoint(recievePort);
    }

    std::string reply = "handshake_ack";
    boost::asio::post(io_context_,[this, endpoint,reply]() mutable {
        socket_.send_to(boost::asio::buffer(reply), endpoint);
    });
}

void VoiceServer::handleHeartbeat(const std::string &client_id, const udp::endpoint &endpoint, std::string_view msg)
{
    std::string username = std::string(msg.substr(10));
    std::lock_guard<std::mutex> lock(session_mutex_);
    auto it = client_sessions_.find(client_id);
    if (it != client_sessions_.end())
    {
        it->second->updateHeartbeat();
        it->second->updateLastActive();
        it->second->SetUserName(username);
        audio_stream_manager_.UpdateClients(it->second->User_Name);
    }
    else
    {
        auto session = std::make_shared<ClientSession>(endpoint);
        client_sessions_[client_id] = session;
        session->SetUserName(username);
    }
}

void VoiceServer::handleGetUsers(const std::string &client_id, const udp::endpoint &endpoint)
{
    boost::asio::post(io_context_,[this, endpoint]() mutable {
        socket_.send_to(getDistinctUserNamesJson(client_sessions_), endpoint);
    });
}

void VoiceServer::handleReceive(const std::string &client_id, const udp::endpoint &endpoint)
{
    std::lock_guard<std::mutex> lock(session_mutex_);
    auto it = client_sessions_.find(client_id);
    if (it != client_sessions_.end())
    {
        boost::asio::post(io_context_,[ this, ep = it->second->recievePoint] {
            socket_.send_to(boost::asio::buffer("copy"), ep);
        });
    }
}

void VoiceServer::setSpeaking(const std::string &client_id, bool speaking)
{
    std::lock_guard<std::mutex> lock(session_mutex_);
    auto it = client_sessions_.find(client_id);
    if (it != client_sessions_.end())
        it->second->IsSpeaking = speaking;
}

void VoiceServer::handleAudio(const std::string &client_id, const std::vector<char> &data)
{
    std::lock_guard<std::mutex> lock(session_mutex_);
    auto it = client_sessions_.find(client_id);
    if (it == client_sessions_.end() || it->second->IsMute)
        return;
    audio_stream_manager_.receiveAudio(data, it->second->User_Name, it->second->recievePoint);
}

void VoiceServer::cleanupInactiveSessions()
{
    std::lock_guard<std::mutex> lock(session_mutex_);
    for (auto it = client_sessions_.begin(); it != client_sessions_.end();)
    {
        if (!it->second->isActive())
        {
            std::cout << "Removing inactive client: " << it->first << std::endl;
            it = client_sessions_.erase(it);
        }
        else
        {
            ++it;
        }
    }
}
